### 사전지식 : 
> 리액트 컴포넌트는 클래스형 컴포넌트(Class Component)와 함수형 컴포넌트(Functional Component)로 나누어 지며, 기본적으로 함수형 컴포넌트+hook을 주로 사용됨.


Hook이란?
--
(React Hooks)  
### 등장 배경  
다음과 같은 클래스형 컴포넌트 단점으로 인하여..  
* 컴포넌트 사이에서 상태 관련 Logic의 재사용이 어렵습니다.  
> 클래스형 컴포넌트에서는 컴포넌트 자체를 재사용 할 수는 있지만
Component class 부분적인 API 사용 및 state를 다루는 등의 처리에는 재사용에 제약이 따릅니다.  
* 코드가 길고 복잡해져 이해하기 어렵다.  
> constructor, this, binding 등  앞서 다룬 라이프사이클 메소드 기반으로 쪼개어 기본 규칙을 따르지 않는 다면 경고 메세지가 표현 되기도 하고, 컴파일이 진행 되지 않을 수도 있고
기본 규칙을 반드시 따라야 하기 때문에 코드가 복잡하고 길어짐.
=>  복잡해져서 이해하기 어렵다 !  

### 함수형 컴포넌트 Hook 처리
1. Hook 처리시 장점  
• 함수형 컴포넌트에서는 원하는 기능을 함수로 만든 후 필요한 곳에 넣어주기만 하면 되기 때문에 로직의 재사용이 유연해 집니다.  
• Hook 을 통해 서로 비슷한 역할의 작은 함수의 묶음으로 컴포넌트를 나누어
클래스형 컴포넌트가 가지고 있던 복잡성, 재사용성의 단점들까지 해결 된다.

`` Hook은 간단히 말하면 함수 컴포넌트에서 클래스 컴포넌트의 
React state(상태관리)와 생명주기메소드(lifecycle method)를
“연동(hook into)“할 수 있게 해주는 함수입니다.``


출처: <https://bravenamme.github.io/2020/04/08/react-hook/>   
출처: <https://ykss.netlify.app/react/hooks/> 

그중에서도 중요하다 생각된 Hook 세가지를 간략하게 예시와 함께 설명드린 후 마무리하겠습니다.
 
	1. useState
	2. useEffect
	3. useRef
## useState
useState는 state hook이다. 

useState는 state와 setState()로 나뉘며 초기에 initialValue를 받고,   
해당 초기값은 처음 렌더링시에만 사용한다.  
useState -> 동적으로 바뀌도록 상태관리 .  
const[number, setNumber] = useState(0);  

> 동적으로 바뀌는 상태값에 대해서
다음 간단한 소스 예제를 보면서 이해를 도와드리겠습니다.  =>CounterUseState (value 값)

> 하나의 useState 함수는 하나의 상태 값만 관리를 할 수 있기 때문에 만약에 컴포넌트에서 관리해야 할 상태가 여러 개라면 useState 를 여러번 사용하면 됩니다.  

>여러 번 사용에 대한 부분 또한
다음 간단한 소스 예제를 보면서 이해를 도와드리겠습니다.=>CounterUseState ( name, nickname 값)

 
## useEffect
useEffect는 effect hook입니다.  
리액트 컴포넌트가 렌더링 될 때마다 특정작업을 수행하도록 설정할 수 있는 Hook


 React class의 componentDidMount나 componentDidUpdate,   componentWillUnmount와 같은 목적으로 제공되지만,   
하나의 API로 통합된 것입니다.  
리액트는 기본적으로 렌더링 이후에 effect를 실행한다.   
그리고 effect 함수는 컴포넌트 내에 있기 떄문에 props와 state에 접근할 수 있으며 
 첫번쨰 렌더링과 이후 업데이트 시 마다 effect가 수행된다.  
화면이 사라질 때 함수를 반환할 수 있는데  
이를 cleanup함수라고 합니다.(state에서 값을 지움).


> 동적으로 바뀌는 상태값에 대해서 렌더링 이후 effect 가 실행되고 업데이트 시마다 effect 가 실행 되는것에 대해서
다음 간단한 소스 예제를 보면서 이해를 도와드리겠습니다.  =>InfoUseEffeect (value 값)  

> 그런데 렌더링 될 때만 실행이 되고 업데이트 될 때마다 effect 를 실행하고 싶지 않을 수 있습니다.
그럴 때는 함수의 두번째 파라미터에 빈 배열을 넣어 실행하면 됩니다.

> 특정 값이 업데이트 될 때만 effect 를 실행하고 싶을 에 대해서
빈 배열 대신 원하는 특정 값을 넣어주면 됩니다. 다음 예제를 보면서 이해를 도와드리겠습니다.=>[] 대신에 name이나 nickname사용


useEffect(()=>{  
console.log('렌더링')  
})  
// 두번째 인자에 빈 배열을 추가하면 한번 실행 후 더이상 관찰하지 않는다.   로딩 타이밍에 처음에 한번만 실행된다.  
useEffect(()=>{  
console.log('렌더링')  
},[])  

화면이 사라질 때 cleanup함수, 뒷정리를 해준다.
함수의 두번째 파라미터를 생략하게 되면 컴포넌트가 리렌더링 될 때마다 호출이 됩니다.


## useRef
useRef는함수형 컴포넌트에서 ref 를 쉽게사용할 수 있게합니다.
	
	• javascript에서 특정 Dom을 선택하는 역할 ex) getElementById, querySelector
	• 특정 DOM에 접근할 때 사용한다.(포커싱)
	• 외부 라이브러리 사용할때 유용하다.
	• 원하는 위치에 ref={} 의 형태로 작성하면 된다.
	• 포커스를 잡으려면 '객체명'.current.focus() 형태로 작성하면 된다.
	• 다시 랜더링 되더라도 동일한 참조값을 유지할 때 !(ex : 스크롤바 위치 가져오기)

특정 DOM 을 선택해야하는 상황컴포넌트 안에서 조회 및 수정 할 수 있는  변수 관리  
특정 값에 포커스하는 예제를 보면서 이해를 도와드리겠습니다. =>InputSample.js

컴포넌트 안에서 조회 및 수정 할 수 있는  변수 관리  
리액트 컴포넌트에서의  상태는 useState와 같은 상태를 바꾸는 함수를 호출 후 렌더링 이후에   
바뀐 상태(state)를 조회할 수 있으나 useRef 로 관리하는   변수는  설정 후 바로 조회할 수 있습니다.  
(이 때 배열을 변화시킬 때는 객체와  마찬가지로  
불변성을 지켜줘야함, push , splice, sort 등의  함수 사용금지, 사용해야한다면 기존의 배열을 한번 복사 후 사용.  
방법은 2가지로 spread 연산자 사용{객체 혹은 배열을 펼친다 라는 뜻...}과 concat 함수 사용{기존의 배열을 수정하지 않고 새로운 원소가 추가된 새로운 배열 생함})  

빈 배열 다음 예제를 보면서 이해를 도와드리겠습니다.  =>AppuseRef.js



## useReducer
useState보다 컴포넌트에서 더 다양한  상황에 따라 다양한 상태를 다른 값으로 업데이트 해주고 싶을 때 사용하는 Hook.  
## 콜백함수  
리액트의 데이터 흐름은 단방향이며,  
prop 를 통해 부모 컴포넌트에서 자식컴포넌트로만 어떠한 값이나 함수를 전달할수 있으나 콜백함수  이용하여 자식 컴포넌트의 값을 부모 컴넌트의 함수에서 사용할 수 있다.(부모가 데이터 관리, 자식에게 데이터 조작기능을 넘기는)
